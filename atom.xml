<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://SeverusNg.github.io</id>
    <title>蒟蒻博客</title>
    <updated>2020-07-30T01:07:23.777Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://SeverusNg.github.io"/>
    <link rel="self" href="https://SeverusNg.github.io/atom.xml"/>
    <subtitle>蒟蒻爱吃蒟蒻～</subtitle>
    <logo>https://SeverusNg.github.io/images/avatar.png</logo>
    <icon>https://SeverusNg.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 蒟蒻博客</rights>
    <entry>
        <title type="html"><![CDATA[次小生成树学习笔记]]></title>
        <id>https://SeverusNg.github.io/post/ci-xiao-sheng-cheng-shu-xue-xi-bi-ji/</id>
        <link href="https://SeverusNg.github.io/post/ci-xiao-sheng-cheng-shu-xue-xi-bi-ji/">
        </link>
        <updated>2020-07-29T19:44:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前置知识"><strong>前置知识</strong></h1>
<ul>
<li>
<p>最小生成树Kruskal算法</p>
</li>
<li>
<p>最近公共祖先LCA</p>
</li>
</ul>
<h1 id="引入问题"><strong>引入问题</strong></h1>
<h2 id="定义"><strong>定义</strong></h2>
<p>一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的<u><strong><strong><strong>次少</strong></strong></strong></u>的边。</p>
<h2 id="模板题"><strong>模板题</strong></h2>
<p><a href="https://www.luogu.com.cn/problem/P4180">洛谷P4180 [BJWC2010]严格次小生成树</a></p>
<h1 id="解决方法"><strong>解决方法</strong></h1>
<h2 id="想法"><strong>想法</strong></h2>
<p>把所有生成树按照权值之和从小到小排序，求排在第二位的生成树。注意，如果最小生成树不唯一，次小生成树的权值和最小生成树相同。</p>
<h2 id="解法一"><strong>解法一</strong></h2>
<p>次小生成树不会和最小生成树相同，因此可以枚举最小生成树中不在次小生成树中出现的边。 注意最小生成树只有n-1条边，所以只需枚举n-1次。每次在剩下的边里，求一次最小生成树。</p>
<p>###<strong>步骤</strong></p>
<ol>
<li>
<p>Kruskal算法求出最小生成树</p>
</li>
<li>
<p>枚举最小生成树的每一条边，对这条边做标记，再进行一次Kruskal算法，Kruskal算法中，跳过被标记的边，求最小生成树，记录答案。</p>
</li>
<li>
<p>去步骤2中所记录答案的最小值即为次小生成树的边权之和。(可直接在步骤2中进行)</p>
</li>
</ol>
<h3 id="复杂度"><strong>复杂度</strong></h3>
<ol>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>M</mi><mi>log</mi><mo>⁡</mo><mi>M</mi><mo>+</mo><mi>M</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(M\log M+M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>M</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(NM)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
</li>
</ol>
<p>总复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi mathvariant="normal">（</mi><mi>N</mi><mi>M</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O（NM)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord cjk_fallback">（</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span></p>
<p><strong><strong>有没有更快些的解决方法呢？</strong></strong></p>
<h2 id="补充知识"><strong>补充知识</strong></h2>
<h3 id="可行交换与临集"><strong>可行交换与临集</strong></h3>
<ul>
<li>
<p>T为图G的一棵生成树，对于非树边a和树边b，插入边a并且删除边b的操作记为(+a,-b)</p>
</li>
<li>
<p>如果T+a-b仍然是一棵生成树，称(+a,-b)是一个可行交换</p>
</li>
<li>
<p>由T进行一次可行交换以后得到的新的生成树的集合称为T的临集</p>
</li>
</ul>
<p>显然，可得定理：<strong><strong><u>次小生成树在最小生成树的临集中</u></strong></strong></p>
<h2 id="更好的解法"><strong>更好的解法</strong></h2>
<ul>
<li>枚举要加入哪条新边，在最小生成树中加入一条边u-v以后，图上会出现一条回路，如果想保持该图为生成树，需删除一条边，删除的边必须是在最小生成树上u到v的路径上，如果想要删除边后的新的生成树有可能为次小生成树，必须要求删除的边这条路径的最长边。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://SeverusNg.github.io/post-images/1596060649544.png" alt="" loading="lazy"></figure>
<p>如图，枚举出一条不在最小生成树上的边E1，如果连接E1，E1两端点为(1,4)，如果想连接E1后依然保证新图为生成树，需删除路径(1,4)上一条最小生成树上的边。为了求出**<u>次小</u>**生成树，我们选择删除原树上的尽可能大的边，即删除边(3,4)，连接边E1。</p>
<figure data-type="image" tabindex="2"><img src="https://SeverusNg.github.io/post-images/1596060641167.png" alt="" loading="lazy"></figure>
<p>如图为新生成的树。</p>
<p>总结一下，新的算法是这样的</p>
<ul>
<li>求出最小生成树之后，枚举每一个不在树上的边，对于边(u,v)，连上此边，删去原来树上路径(u,v)上最长的边。</li>
<li>题目中要求的是**<u>严格</u>**次小生成树，因此，当原来树上路径(u,v)上最长的边的权值等于新连边(u,v)时，是不符合要求的，我们需要找次长边。</li>
</ul>
<p>那么枚举每一条边复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>M</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>，对每一条边用dfs求(u,v)上的最长&amp;次长边，复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，总复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>M</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(MN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>没有遍低呀～</p>
<p>因此，我没需要对算法进行优化，可以通过dfs<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>来预处理每个点到其k代父节点的路径上的最长边和次长边，再通过lca倍增的方法在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>复杂度下求出u,v两点之间的最长边和次长边。</p>
<h3 id="预处理">预处理</h3>
<p>对于每一个点u，我们记记录anc[u][k]数组，u是节点编号，k代表其$2^k $代父节点。</p>
<p>记录m1[u][k]数组，其中，u是节点编号，k代表从u节点往上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>个点，数组的值是u点到u节点上方$2^k $个点间的最长边，可得状态转移方程</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mn>1</mn><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><mi>m</mi><mn>1</mn><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>m</mi><mn>1</mn><mo>[</mo><mi>a</mi><mi>n</mi><mi>c</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">m1[u][k]=\max(m1[u][k-1],m1[anc[u][k-1]][k-1])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>记录m2[u][k]数组，u,k含义同m1，数组的值是u点到u节点上方$2^k $个点间的次长边，可得状态转移方程</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mn>2</mn><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>max</mi><mo>⁡</mo><mo>(</mo><mi>m</mi><mn>2</mn><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>m</mi><mn>2</mn><mo>[</mo><mi>a</mi><mi>n</mi><mi>c</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>m</mi><mn>1</mn><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mi mathvariant="normal">≠</mi><mi>m</mi><mn>1</mn><mo>[</mo><mi>a</mi><mi>n</mi><mi>c</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>m</mi><mn>1</mn><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>m</mi><mn>1</mn><mo>[</mo><mi>a</mi><mi>n</mi><mi>c</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>m</mi><mn>1</mn><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>=</mo><mi>m</mi><mn>1</mn><mo>[</mo><mi>a</mi><mi>n</mi><mi>c</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">m2[u][k]=\begin{cases}  \max(m2[u][k-1],m2[anc[u][k-1][k-1]),  &amp; \text{if }m1[u][k-1]\ne m1[anc[u][k-1]][k-1] \\ \min(m1[u][k-1],m1[anc[u][k-1][k-1]), &amp; \text{if }m1[u][k-1]= m1[anc[u][k-1]][k-1] \end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathdefault">m</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathdefault">m</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>经过一次dfs后，我们即可预处理完成以上内容。</p>
<p>遍历<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个点，每个点要进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\log N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>次计算，复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<h3 id="lca同时求值">LCA同时求值</h3>
<p>对于点u和v，我们在有预处理的情况下想求其两点之间路径的最长边和次长边，可进行以下操作</p>
<p>用倍增法求LCA的方式将两个点向上跳，跳的同时记录m1和m2的值。</p>
<p>向上跳的做法与倍增法求LCA相同，如果没有了解，请先学习倍增法求LCA，此处不做过多介绍。</p>
<p>具体代码如下：</p>
<pre><code class="language-c++"> /*参数ma为要新建的边的权值，因为要求严格次小生成树，
 所以在原树中删除的边必须严格小于新建的边的权值，
 即lca函数的返回值（也就是在原树中删除的边的权值）需严格小于参数ma。*/
long long findBig(long long u,long long i,long long ma){
    if(m1[u][i]!=ma){
        return m1[u][i];
    }
    return m2[u][i];
}
long long lca(long long u,long long v,long long ma){
    if(dep[u]&lt;dep[v]){
        swap(u,v);
    }
    long long res = -INF;
    for(int i = 20;i&gt;=0;--i){
        if(dep[ancestor[u][i]]&lt;dep[v]){
            continue;
        }
        res = max(res,findBig(u,i,ma));
        u = ancestor[u][i];
    }
    if(u==v){
        return res;
    }
    for(int i = 20;i&gt;=0;--i){
        if(ancestor[u][i]!=ancestor[v][i]){
            res = max(res,findBig(u,i,ma));
            res = max(res,findBig(v,i,ma));
            u = ancestor[u][i];
            v = ancestor[v][i];
        }
    }
    res = max(res,findBig(u,0,ma));
    res = max(res,findBig(v,0,ma));
    return res;
}
</code></pre>
<h3 id="步骤">步骤</h3>
<ol>
<li>Kruskal算法求出最小生成树</li>
<li>dfs预处理</li>
<li>枚举每一条不在最小生成树上的边，求出最小生成树上的边权之和加上该边之和，减去该边所连两点在原树上的路径间的最长边（次长边），即为新的生成树的边权之和，记录答案。</li>
<li>在步骤3中，所记录答案的最小值即为次小生成树的边权之和。（可直接在步骤3中进行）</li>
</ol>
<h3 id="复杂度-2">复杂度</h3>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>M</mi><mi>log</mi><mo>⁡</mo><mi>M</mi><mo>+</mo><mi>M</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(M\log M+M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N\log N )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>M</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(M\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ol>
<p>总复杂度为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>M</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(MlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<h3 id="具体代码">具体代码</h3>
<pre><code class="language-c++">//
// Created by 吴习哲 on 2020/7/24.
//

#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;

const long long MAXN = 100005;
const long long MAXM = 300005;
const  long long INF = 0x3f3f3f3ff3f3f3f;
using namespace std;

struct edge{
    long long u,v,w;
    int next;
    bool operator&lt;(const edge &amp;e)const{
        return w&lt;e.w;
    }
} ed[MAXM*2],pool[MAXM];
int head[MAXN];
int topE;
void addE(int u,int v,int w){
    ed[++topE].u = u;
    ed[topE].v = v;
    ed[topE].w = w;
    ed[topE].next = head[u];
    head[u] = topE;
    return;
}
int fa[MAXN];

int find(int u){
    if(fa[u]==u){
        return fa[u];
    }
    fa[u] = find(fa[u]);
    return fa[u];
}
void merge(int u,int v){
    u = find(u);
    v = find(v);
    fa[u] = v;
    return;
}

bool use[MAXM];

long long N,M;
long long mst;
void kruskal(){
    sort(pool+1,pool+M+1);
    for(int i = 1;i&lt;=M;++i){
        long long u = pool[i].u;
        long long v = pool[i].v;
        long long w = pool[i].w;
        if(find(u)!=find(v)){
            mst += w;
            merge(u,v);
            addE(u,v,w);
            addE(v,u,w);
            use[i]=true;
        }
    }
    return;
}
int dep[MAXN];

int ancestor[MAXN][25];
long long m1[MAXN][25];
long long m2[MAXN][25];
long long findBig(long long u,long long i,long long ma){
    if(m1[u][i]!=ma){
        return m1[u][i];
    }
    return m2[u][i];
}
void dfs(long long u,long long father,long long w){
    ancestor[u][0] = father;
    dep[u] = dep[father]+1;
    m1[u][0]=w;
    m2[u][0]=-INF;
    for(int i = 1;i&lt;=20;++i){
        ancestor[u][i]=ancestor[ancestor[u][i-1]][i-1];
        m1[u][i]=max(m1[u][i-1],m1[ancestor[u][i-1]][i-1]);
        m2[u][i]=max(m2[u][i-1],m2[ancestor[u][i-1]][i-1]);
        if(m1[u][i-1]!=m1[ancestor[u][i-1]][i-1]){
            m2[u][i]=max(m2[u][i],min(m1[u][i-1],m1[ancestor[u][i-1]][i-1]));
        }
    }
    for(int i = head[u];i!=0;i=ed[i].next){
        long long u,v,w;
        u = ed[i].u;
        v = ed[i].v;
        w = ed[i].w;
        if(v==father){
            continue;
        }
        dfs(v,u,w);
    }
    return;
}

long long lca(long long u,long long v,long long ma){
    if(dep[u]&lt;dep[v]){
        swap(u,v);
    }
    long long res = -INF;
    for(int i = 20;i&gt;=0;--i){
        if(dep[ancestor[u][i]]&lt;dep[v]){
            continue;
        }
        res = max(res,findBig(u,i,ma));
        u = ancestor[u][i];
    }
    if(u==v){
        return res;
    }
    for(int i = 20;i&gt;=0;--i){
        if(ancestor[u][i]!=ancestor[v][i]){
            res = max(res,findBig(u,i,ma));
            res = max(res,findBig(v,i,ma));
            u = ancestor[u][i];
            v = ancestor[v][i];
        }
    }
    res = max(res,findBig(u,0,ma));
    res = max(res,findBig(v,0,ma));
    return res;
}
int main(){
    scanf(&quot;%lld%lld&quot;,&amp;N,&amp;M);
    for(int i = 1;i&lt;=N;++i){
        fa[i] = i;
    }
    for(int i = 1;i&lt;=M;++i){
        scanf(&quot;%lld%lld%lld&quot;,&amp;pool[i].u,&amp;pool[i].v,&amp;pool[i].w);
    }
    kruskal();
    dfs(1,0,-INF);
    long long ans = INF;
    for(int i = 1;i&lt;=M;++i){
        if(use[i]){
            continue;
        }
        long long u = pool[i].u;
        long long v = pool[i].v;
        long long w = pool[i].w;
        ans = min(ans,mst+w-lca(u,v,w));
    }

    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
<hr>
<p>嘤嘤嘤，完结撒花～</p>
<p>啊，从建博客，各种调试，到写完这一篇文章，再加上摸鱼，抬头一看，天已经亮了，搞了一个通宵～</p>
<p>不过看到成果，内心还是十分高兴的～</p>
<p>如有错误，希望巨佬您能够在评论区指正，感激不尽～</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重启博客]]></title>
        <id>https://SeverusNg.github.io/post/chong-qi-bo-ke/</id>
        <link href="https://SeverusNg.github.io/post/chong-qi-bo-ke/">
        </link>
        <updated>2020-07-28T20:08:05.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>说来也巧，因为疫情，上了好几个月的网课，其实也就是摸了好几个月的鱼～<br>
最近在梁博老师的信息课上，遇到了一个初一的小孩，rui_er刷的题比我还多，知识点学的也比我丰富。而且我更羡慕的是他的年龄，才刚刚初一啊～（梁老师预测他初三能进省队）梁老师在课上提到，学oi主要靠自学和做题，他认识的大佬都是自己主动积极打cf比赛，以及写题解博客。<br>
我又不是巨佬，我只是一只爱吃蒟蒻的蒟蒻，但是听梁老师这么一说，想起来许久之前，我也建过一个博客。<br>
还得从初三说起～<br>
当时特长生考试完，闲的无聊，就用hexo搭建了一个博客。<br>
里面大概写了一点瞎搞的技术博文，后来就不了了之了，一是因为换电脑，二是因为hexo写博客真的很麻烦。然后那个网站就永久关闭了～<br>
结合之前的博客经验，外加两位梁老师都推荐写博客，我就在有了重启博客的计划。<br>
只不过这一次写博客不像上次那样完全没有经验，我想信竞选手这么多，应该有一些比较完美的解决方案～<br>
百度了一下“洛谷 写博客”，果然看到了一篇洛谷日报是关于写博客的，点进去一看，里面推荐了一个很强的东西，貌似是今年（2020年）3月份刚开发出来的，一个可以直接一件部署的博客客户端——gridea<br>
再一看效果展示，感觉很不错，仔细一看名字，我去，就是跟我一个课外班的那个初一同学——rui_er，这位巨佬初一就写的文章居然就上了洛谷日报......<br>
然后呢，就是下载gridea，买了一个阿里云的学生优惠北京ECS，但是需要备案......<br>
没办法，就只能用githu提供的仓库来搞，然后，就是现在这个样子～</p>
<h1 id="要干什么">要干什么</h1>
<p>话说这次重启博客和上一次不太一样，这一次我准备尝试长时间维护一下这个博客～<br>
那么博客内容，我计划以下几点为主<br>
1.信竞题解/笔记<br>
2.各种计算机方面的东东<br>
3.瞎扯淡～<br>
貌似这3点（尤其是第3点），就已经囊括了所有我能接触到的内容～</p>
<h1 id="目的是什么">目的是什么</h1>
<h2 id="巩固学习">巩固学习</h2>
<p>目前暑假，这几节课学的算法很多，密度比较大，而且难度还可以，倒不是很难。但是毕竟有些算法是第一次接触，代码的话，不经常写可能会忘记，但是相关的题并没有很多，做的相关的题就更少了，写一遍笔记类博客有助于学习本身。</p>
<h2 id="交流">交流</h2>
<p>很多巨佬都写博客，虽然我是蒟蒻，但是写博客能让很多巨佬看到我的内容，如果内容中有错误或者有值得改进的地方，乐于助人的巨佬能够指出来，对我的裨益很大。而且我认为表达能力也很重要，本身我语文水平就极差，从初中就极差，到了高中更是极差，写博客应该能对这个有一些锻炼（吧）。同时，借着博客之名，和巨佬一起交流，这点很nice😝～social也是很重要的一点，学习上有一些事情是不能闭门造车的，而且和巨佬们交流能提升学习动力，不然的话，很容易颓<br>
<img src="https://SeverusNg.github.io/post-images/1596046139812.JPG" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>说来也巧，因为疫情，上了好几个月的网课，其实也就是摸了好几个月的鱼～<br>
最近在梁博老师的信息课上，遇到了一个初一的小孩，rui_er刷的题比我还多，知识点学的也比我丰富。而且我更羡慕的是他的年龄，才刚刚初一啊～（梁老师预测他初三能进省队）梁老师在课上提到，学oi主要靠自学和做题，他认识的大佬都是自己主动积极打cf比赛，以及写题解博客。<br>
我又不是巨佬，我只是一只爱吃蒟蒻的蒟蒻，但是听梁老师这么一说，想起来许久之前，我也建过一个博客。<br>
还得从初三说起～<br>
当时特长生考试完，闲的无聊，就用hexo搭建了一个博客。<br>
里面大概写了一点瞎搞的技术博文，后来就不了了之了，一是因为换电脑，二是因为hexo写博客真的很麻烦。然后那个网站就永久关闭了～<br>
结合之前的博客经验，外加两位梁老师都推荐写博客，我就在有了重启博客的计划。<br>
只不过这一次写博客不像上次那样完全没有经验，我想信竞选手这么多，应该有一些比较完美的解决方案～<br>
百度了一下“洛谷 写博客”，果然看到了一篇洛谷日报是关于写博客的，点进去一看，里面推荐了一个很强的东西，貌似是今年（2020年）3月份刚开发出来的，一个可以直接一件部署的博客客户端——gridea<br>
再一看效果展示，感觉很不错，仔细一看名字，我去，就是跟我一个课外班的那个初一同学——rui_er，这位巨佬初一就写的文章居然就上了洛谷日报......<br>
然后呢，就是下载gridea，买了一个阿里云的学生优惠北京ECS，但是需要备案......<br>
没办法，就只能用githu提供的仓库来搞，然后，就是现在这个样子～</p>
<h1 id="要干什么">要干什么</h1>
<p>话说这次重启博客和上一次不太一样，这一次我准备尝试长时间维护一下这个博客～<br>
那么博客内容，我计划以下几点为主<br>
1.信竞题解/笔记<br>
2.各种计算机方面的东东<br>
3.瞎扯淡～<br>
貌似这3点（尤其是第3点），就已经囊括了所有我能接触到的内容～</p>
<h1 id="目的是什么">目的是什么</h1>
<h2 id="巩固学习">巩固学习</h2>
<p>目前暑假，这几节课学的算法很多，密度比较大，而且难度还可以，倒不是很难。但是毕竟有些算法是第一次接触，代码的话，不经常写可能会忘记，但是相关的题并没有很多，做的相关的题就更少了，写一遍笔记类博客有助于学习本身。</p>
<h2 id="交流">交流</h2>
<p>很多巨佬都写博客，虽然我是蒟蒻，但是写博客能让很多巨佬看到我的内容，如果内容中有错误或者有值得改进的地方，乐于助人的巨佬能够指出来，对我的裨益很大。而且我认为表达能力也很重要，本身我语文水平就极差，从初中就极差，到了高中更是极差，写博客应该能对这个有一些锻炼（吧）。同时，借着博客之名，和巨佬一起交流，这点很nice😝～social也是很重要的一点，学习上有一些事情是不能闭门造车的，而且和巨佬们交流能提升学习动力，不然的话，很容易颓<br>
<img src="https://SeverusNg.github.io/post-images/1596046139812.JPG" alt="" loading="lazy"></p>
<!-- more -->
<p>嘤嘤嘤，大概就是这样了，<br>
我是小小吴，本来想叫小吴的，但我高中数学老师已经是小吴了。。。<br>
嘤嘤嘤，本蒟蒻在这里膜一下看此博客的巨佬，如果之后的博客里有什么错误，还望您能够直接指出，像我这么蒟蒻，错误估计不少。<br>
嘤嘤嘤，如果巨佬您有什么别的事情（瞎扯淡什么的），也可以在下面评论，可以探讨探讨各种问题，（比如蒟蒻怎么做好吃，凉拌还是放到麻辣香锅里等等）</p>
<p>嘤嘤嘤，这篇blog就到这里啦～<br>
<img src="https://SeverusNg.github.io/post-images/1596046662375.JPG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Python+Tesseract实现图片转文字]]></title>
        <id>https://SeverusNg.github.io/post/shi-yong-pythontesseract-shi-xian-tu-pian-zhuan-wen-zi/</id>
        <link href="https://SeverusNg.github.io/post/shi-yong-pythontesseract-shi-xian-tu-pian-zhuan-wen-zi/">
        </link>
        <updated>2020-07-28T20:04:40.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>title: 使用Python+Tesseract实现图片转文字<br>
date: 2019-06-15 10:42:41<br>
tags:</p>
<hr>
<h1 id="前言">前言</h1>
<p>端午节第二天，早晨吃完竹筒饭后，10:00左右收到老师微信，为了弥补我吃的一顿霸王餐，需要把图片转成word发给老师。一共6张图片，打字的话大概40分钟。但我好歹是个OIer（虽然提高组没拿到奖 ），怎么可能打40分钟的字呢？要是有办法能自动转换，这样的事情以后一劳永逸啊。</p>
<p>经过长达6小时的百度和实践后，我成功实现了图片转文字。但是在这个过程中，有许多博客时间过于古老，错误频出。所以准备写一篇关于Tesseract实现图片转文字（OCR）的博客。</p>
<h1 id="生产环境">生产环境</h1>
<p>系统 macOS Sierra 10.12.6</p>
<p>语言 Python3.6</p>
<p>软件 Homebrew</p>
<h1 id="安装程序">安装程序</h1>
<h2 id="升级生产环境">升级生产环境</h2>
<p>安装／升级软件至与生产环境中相同</p>
<h2 id="安装tesseract">安装Tesseract</h2>
<p>打开Terminal</p>
<p>输入指令</p>
<pre><code class="language-shell">brew install tesseract
</code></pre>
<p>下载完毕后，输入指令查看版本</p>
<pre><code class="language-shell">tesseract --version
</code></pre>
<p>如果输出tesseract x.x.x 那么恭喜你，下载成功，如果报错。那么请再次下载，直至成功。</p>
<h2 id="安装pytesseract">安装Pytesseract</h2>
<p>输入指令</p>
<pre><code class="language-shell">pip3 install pytesseract
</code></pre>
<p>下载完毕后，进入下一阶段。</p>
<h2 id="安装中文语言包">安装中文语言包</h2>
<p>打开https://github.com/tesseract-ocr/tessdata</p>
<p>下载其中的<a href="https://github.com/tesseract-ocr/tessdata/blob/master/chi_sim.traineddata">chi_sim.traineddata</a></p>
<p>将该文件复制到</p>
<p>/usr/local/Cellar/tesseract/4.0.0（版本号）/share/tessdata</p>
<p>如果根目录下没有显示usr文件</p>
<p>同时按下<code>Command+shift+.</code>可显示隐藏文件。</p>
<p>复制完后，输入</p>
<pre><code class="language-shell">tesseract --list-langs
</code></pre>
<p>显示的语言中若包含<code>chi_sim</code>，说明安装成功。</p>
<h1 id="简单使用方法">简单使用方法</h1>
<p>新建文件夹，编辑一个新的python文件。输入</p>
<pre><code class="language-python">import pytesseract
from PIL import Image

open image

file = open('输出文件.txt','w')
for i in range(1,7):
	image = Image.open('需要识别的图片.jpg')
	code = pytesseract.image_to_string(image, lang='chi_sim')
	file.write(code)
	file.write('\n')
file.close()
</code></pre>
<p>运行该程序，会识别文件夹下（需要识别的图片.jpg），并生成（输出文件.txt ）</p>
<p>更多Python相关基础语法本篇博客不做介绍</p>
<p>更多关于pytesseract的使用方法请移步<a href="https://pypi.org/project/pytesseract/">Pytesseract官网</a></p>
<p>更多关于tesseract的使用方法请移步<a href="https://github.com/tesseract-ocr/tesseract/wiki">Tesseract官方Wiki</a></p>
<h1 id="训练模型">训练模型</h1>
<p>挖坑待填</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSL证书即https前缀获取方法]]></title>
        <id>https://SeverusNg.github.io/post/ssl-zheng-shu-ji-https-qian-zhui-huo-qu-fang-fa/</id>
        <link href="https://SeverusNg.github.io/post/ssl-zheng-shu-ji-https-qian-zhui-huo-qu-fang-fa/">
        </link>
        <updated>2020-07-28T20:00:53.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>title: SSL证书即https前缀获取方法<br>
date: 2019-06-16 13:44:32<br>
tags:</p>
<hr>
<h1 id="前言">前言</h1>
<p>博客网站建立后，准备引入BidVertiser广告系统。但是需要https前缀，使用SSL证书。SSL证书使用不是很麻烦，速度也比较快。</p>
<h1 id="生产环境">生产环境</h1>
<p>系统 Ubuntu 18.04 x64</p>
<p>软件 Nginx</p>
<h1 id="购买ssl证书">购买SSL证书</h1>
<p>登陆阿里云账号，前往SSL证书<a href="https://common-buy.aliyun.com/?spm=5176.2020520163.cas.3.487ewFPZwFPZbR&amp;commodityCode=cas#/buy">购买页面</a>，选择免费DV型 SSL。</p>
<p>购买后绑定域名，提交审核。</p>
<p>审核速度通常很快（1小时内）。</p>
<p>审核通过后前往<a href="https://yundunnext.console.aliyun.com/?spm=5176.12818093.recent.dcas.488716d0XHrUZR&amp;p=cas#/overview/cn-hangzhou">证书管理页面</a>，点击所购买证书中的下载，在弹窗中选择Nginx下载。</p>
<h1 id="部署ssl证书">部署SSL证书</h1>
<h2 id="传输证书">传输证书</h2>
<p>将下载后的证书解压，解压后的文件夹重命名为cert，通过FTP将cert文件夹传输到服务器的/etc/nginx/目录下。</p>
<h2 id="设置配置">设置配置</h2>
<p>进入服务器的/etc/nginx/conf.d目录下，打开defualt（或者你自己的配置文件）</p>
<p>更改原有文件内容为</p>
<pre><code class="language-shell">server {
    listen 443;
    server_name www.xxx.com; #你的域名
    ssl on;
    root /var/www/xxx.com; #你的站点位置
    index index.html index.htm;
    ssl_certificate  cert/xxx.pem;#你的证书名字
    ssl_certificate_key cert/xxx.key;#你的证书名字
    ssl_session_timeout 5m;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers on;
    location / {
        index index.html index.htm;
    }
}
server {
    listen 80;
    server_name www.xxx.com;#你的域名
    rewrite ^(.*)$ https://$host$1 permanent;#把http的域名请求转成https
}
</code></pre>
<p><code>1_xxx.pem</code> 改为证书<code>.pem文件</code>的名称（在阿里云上下载下来的文件解压后的文件夹内）</p>
<p><code>2_xxx.key</code> 改为证书<code>.key文件</code>的名称（在阿里云上下载下来的文件解压后的文件夹内）</p>
<p><code>www.xxx.com</code>改为你的<code>域名</code></p>
<p><code>/var/www/xxx.com</code>改为你的<code>站点位置</code></p>
<p>全部更改完后，配置文件就设置完成了。</p>
<h1 id="启用ssl证书">启用SSL证书</h1>
<h2 id="检查">检查</h2>
<p>输入</p>
<pre><code class="language-shell">nginx -t
</code></pre>
<p>检查Nginx配置文件是否设置成功</p>
<p>如果显示<code>successful</code>代表成功。否则情重复上一步骤。</p>
<h2 id="重启">重启</h2>
<p>输入</p>
<pre><code class="language-shell">nginx -s reload
</code></pre>
<p>重启Nginx，使SSL证书部署生效。</p>
<p>重启后，SSL证书就部署完成了。</p>
<h2 id="查看效果">查看效果</h2>
<p>可以输入<code>https://（你的域名）</code>查看效果。</p>
]]></content>
    </entry>
</feed>